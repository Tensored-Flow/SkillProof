import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";

describe("SkillProofMatchVerifier", function () {
  // Real proof generated by snarkjs from our match_history_proof circom circuit.
  // Circuit: MatchHistoryProof — proves totalMatches >= minMatches AND winRate >= minWinRateBps
  // Input: totalMatches=12, wins=8, salt=54321, minMatches=10, minWinRateBps=6000
  // commitment = totalMatches + wins * 2^16 + salt * 2^32 = 233306919010316

  const VALID_PROOF = {
    pA: [
      "0x1d843248b0d44a9ce1a45ef3e71cc2b409c398bc4ab536d754988f22a3ca1375",
      "0x07656444fb765a7afc66759b2b648b25e4b227edd2c1fbf5d6cd7379775cbc34",
    ] as [string, string],
    pB: [
      [
        "0x22975f7609a2680c5e2f996059e8565aaac221726c4c5f3cb876917172bdd61b",
        "0x295574c962aa63757b98936a95056acbbfd1317ea394d4015cc9a624f201bcdd",
      ],
      [
        "0x0a8c07ee876950ebe9c0bcf589b99f850ed2ef08b5dc2985446419f05a9fd58e",
        "0x23627cf22888477cbb11451b8abed2250c5c3cdc8b7360bf7beb7e68f1ff6afa",
      ],
    ] as [[string, string], [string, string]],
    pC: [
      "0x09442987e7743d92afb340bf1bb513e88f6723b7b1fd3d852b65321635e002fe",
      "0x1fc0621a8f44c0dda708fe154ebc95599868d3affd98a9e9a14e8334a42a98af",
    ] as [string, string],
    pubSignals: [
      "0x000000000000000000000000000000000000000000000000000000000000000a", // minMatches = 10
      "0x0000000000000000000000000000000000000000000000000000000000001770", // minWinRateBps = 6000
      "0x0000000000000000000000000000000000000000000000000000d4310008000c", // commitment
    ] as [string, string, string],
  };

  // Test data matching the proof
  const TOTAL_MATCHES = 12;
  const WINS = 8;
  const SALT = 54321;
  const COMMITMENT = BigInt(TOTAL_MATCHES) + BigInt(WINS) * 65536n + BigInt(SALT) * 4294967296n;

  async function deployMatchVerifierFixture() {
    const [owner, user1, user2] = await ethers.getSigners();

    // Deploy real MatchHistoryGroth16Verifier (snarkjs-generated)
    const Groth16Factory = await ethers.getContractFactory("MatchHistoryGroth16Verifier");
    const groth16Verifier = await Groth16Factory.deploy();

    // Deploy SkillProofMatchVerifier wrapper
    const MatchFactory = await ethers.getContractFactory("SkillProofMatchVerifier");
    const matchVerifier = await MatchFactory.deploy(await groth16Verifier.getAddress());

    return { groth16Verifier, matchVerifier, owner, user1, user2 };
  }

  describe("Deployment", function () {
    it("Should set the Groth16Verifier address", async function () {
      const { groth16Verifier, matchVerifier } = await loadFixture(deployMatchVerifierFixture);
      expect(await matchVerifier.groth16Verifier()).to.equal(
        await groth16Verifier.getAddress()
      );
    });

    it("Should set the owner", async function () {
      const { matchVerifier, owner } = await loadFixture(deployMatchVerifierFixture);
      expect(await matchVerifier.owner()).to.equal(owner.address);
    });

    it("Should start with zero verification count", async function () {
      const { matchVerifier } = await loadFixture(deployMatchVerifierFixture);
      expect(await matchVerifier.matchVerificationCount()).to.equal(0);
    });
  });

  describe("Match Commitment", function () {
    it("Should register valid commitment", async function () {
      const { matchVerifier, user1 } = await loadFixture(deployMatchVerifierFixture);

      await matchVerifier.connect(user1).registerMatchCommitment(TOTAL_MATCHES, WINS, SALT);
      expect(await matchVerifier.matchCommitments(user1.address)).to.equal(COMMITMENT);
    });

    it("Should reject wins > totalMatches", async function () {
      const { matchVerifier, user1 } = await loadFixture(deployMatchVerifierFixture);

      await expect(
        matchVerifier.connect(user1).registerMatchCommitment(5, 10, SALT)
      ).to.be.revertedWith("Invalid: wins > matches");
    });

    it("Should compute commitment correctly", async function () {
      const { matchVerifier, user1 } = await loadFixture(deployMatchVerifierFixture);

      // commitment = totalMatches + wins * 2^16 + salt * 2^32
      const totalMatches = 100;
      const wins = 75;
      const salt = 99999;
      const expected = BigInt(totalMatches) + BigInt(wins) * 65536n + BigInt(salt) * 4294967296n;

      await matchVerifier.connect(user1).registerMatchCommitment(totalMatches, wins, salt);
      expect(await matchVerifier.matchCommitments(user1.address)).to.equal(expected);
    });

    it("Should allow updating commitment", async function () {
      const { matchVerifier, user1 } = await loadFixture(deployMatchVerifierFixture);

      await matchVerifier.connect(user1).registerMatchCommitment(10, 5, 111);
      const first = await matchVerifier.matchCommitments(user1.address);

      await matchVerifier.connect(user1).registerMatchCommitment(20, 15, 222);
      const second = await matchVerifier.matchCommitments(user1.address);

      expect(first).to.not.equal(second);
    });
  });

  describe("Match Verification", function () {
    it("Should reject if no commitment registered", async function () {
      const { matchVerifier, user1 } = await loadFixture(deployMatchVerifierFixture);

      await expect(
        matchVerifier.connect(user1).verifyMatchHistory(
          VALID_PROOF.pA,
          VALID_PROOF.pB,
          VALID_PROOF.pC,
          VALID_PROOF.pubSignals
        )
      ).to.be.revertedWith("Commitment mismatch");
    });

    it("Should reject commitment mismatch", async function () {
      const { matchVerifier, user1 } = await loadFixture(deployMatchVerifierFixture);

      // Register a different commitment
      await matchVerifier.connect(user1).registerMatchCommitment(5, 3, 111);

      await expect(
        matchVerifier.connect(user1).verifyMatchHistory(
          VALID_PROOF.pA,
          VALID_PROOF.pB,
          VALID_PROOF.pC,
          VALID_PROOF.pubSignals
        )
      ).to.be.revertedWith("Commitment mismatch");
    });

    it("Should accept valid proof and emit MatchHistoryVerified event", async function () {
      const { matchVerifier, user1 } = await loadFixture(deployMatchVerifierFixture);

      // Register the correct commitment
      await matchVerifier.connect(user1).registerMatchCommitment(TOTAL_MATCHES, WINS, SALT);

      await expect(
        matchVerifier.connect(user1).verifyMatchHistory(
          VALID_PROOF.pA,
          VALID_PROOF.pB,
          VALID_PROOF.pC,
          VALID_PROOF.pubSignals
        )
      )
        .to.emit(matchVerifier, "MatchHistoryVerified")
        .withArgs(user1.address, 10, 6000, COMMITMENT);
    });

    it("Should record verification data after successful proof", async function () {
      const { matchVerifier, user1 } = await loadFixture(deployMatchVerifierFixture);

      await matchVerifier.connect(user1).registerMatchCommitment(TOTAL_MATCHES, WINS, SALT);
      await matchVerifier.connect(user1).verifyMatchHistory(
        VALID_PROOF.pA,
        VALID_PROOF.pB,
        VALID_PROOF.pC,
        VALID_PROOF.pubSignals
      );

      expect(await matchVerifier.hasVerifiedHistory(user1.address)).to.be.true;
      expect(await matchVerifier.verifiedMinMatches(user1.address)).to.equal(10);
      expect(await matchVerifier.verifiedMinWinRate(user1.address)).to.equal(6000);
      expect(await matchVerifier.matchVerificationCount()).to.equal(1);
    });

    it("Should reject tampered proof", async function () {
      const { matchVerifier, user1 } = await loadFixture(deployMatchVerifierFixture);

      await matchVerifier.connect(user1).registerMatchCommitment(TOTAL_MATCHES, WINS, SALT);

      const tamperedPA: [string, string] = [
        "0x0000000000000000000000000000000000000000000000000000000000000001",
        "0x0000000000000000000000000000000000000000000000000000000000000002",
      ];

      await expect(
        matchVerifier.connect(user1).verifyMatchHistory(
          tamperedPA,
          VALID_PROOF.pB,
          VALID_PROOF.pC,
          VALID_PROOF.pubSignals
        )
      ).to.be.revertedWith("Invalid ZK proof");
    });

    it("Should not record state for rejected proofs", async function () {
      const { matchVerifier, user1 } = await loadFixture(deployMatchVerifierFixture);

      await matchVerifier.connect(user1).registerMatchCommitment(TOTAL_MATCHES, WINS, SALT);

      const tamperedPA: [string, string] = [
        "0x0000000000000000000000000000000000000000000000000000000000000001",
        "0x0000000000000000000000000000000000000000000000000000000000000002",
      ];

      try {
        await matchVerifier.connect(user1).verifyMatchHistory(
          tamperedPA,
          VALID_PROOF.pB,
          VALID_PROOF.pC,
          VALID_PROOF.pubSignals
        );
      } catch {}

      expect(await matchVerifier.hasVerifiedHistory(user1.address)).to.be.false;
      expect(await matchVerifier.matchVerificationCount()).to.equal(0);
    });
  });

  describe("Requirements Check", function () {
    it("Should return false for unverified users", async function () {
      const { matchVerifier, user1 } = await loadFixture(deployMatchVerifierFixture);
      expect(await matchVerifier.meetsMatchRequirements(user1.address, 5, 5000)).to.be.false;
    });

    it("Should return true when thresholds met", async function () {
      const { matchVerifier, user1 } = await loadFixture(deployMatchVerifierFixture);

      await matchVerifier.connect(user1).registerMatchCommitment(TOTAL_MATCHES, WINS, SALT);
      await matchVerifier.connect(user1).verifyMatchHistory(
        VALID_PROOF.pA,
        VALID_PROOF.pB,
        VALID_PROOF.pC,
        VALID_PROOF.pubSignals
      );

      // Verified minMatches=10, minWinRate=6000. Ask for less → true
      expect(await matchVerifier.meetsMatchRequirements(user1.address, 5, 5000)).to.be.true;
      expect(await matchVerifier.meetsMatchRequirements(user1.address, 10, 6000)).to.be.true;
    });

    it("Should return false when minMatches not met", async function () {
      const { matchVerifier, user1 } = await loadFixture(deployMatchVerifierFixture);

      await matchVerifier.connect(user1).registerMatchCommitment(TOTAL_MATCHES, WINS, SALT);
      await matchVerifier.connect(user1).verifyMatchHistory(
        VALID_PROOF.pA,
        VALID_PROOF.pB,
        VALID_PROOF.pC,
        VALID_PROOF.pubSignals
      );

      // Verified minMatches=10 but asking for 20 → false
      expect(await matchVerifier.meetsMatchRequirements(user1.address, 20, 5000)).to.be.false;
    });

    it("Should return false when winRate not met", async function () {
      const { matchVerifier, user1 } = await loadFixture(deployMatchVerifierFixture);

      await matchVerifier.connect(user1).registerMatchCommitment(TOTAL_MATCHES, WINS, SALT);
      await matchVerifier.connect(user1).verifyMatchHistory(
        VALID_PROOF.pA,
        VALID_PROOF.pB,
        VALID_PROOF.pC,
        VALID_PROOF.pubSignals
      );

      // Verified minWinRate=6000 but asking for 7000 → false
      expect(await matchVerifier.meetsMatchRequirements(user1.address, 5, 7000)).to.be.false;
    });
  });

  describe("View Functions", function () {
    it("Should return correct verification details for unverified user", async function () {
      const { matchVerifier, user1 } = await loadFixture(deployMatchVerifierFixture);

      const [verified, minMatches, minWinRate, commitment] =
        await matchVerifier.getVerification(user1.address);

      expect(verified).to.be.false;
      expect(minMatches).to.equal(0);
      expect(minWinRate).to.equal(0);
      expect(commitment).to.equal(0);
    });

    it("Should return correct verification details after proof", async function () {
      const { matchVerifier, user1 } = await loadFixture(deployMatchVerifierFixture);

      await matchVerifier.connect(user1).registerMatchCommitment(TOTAL_MATCHES, WINS, SALT);
      await matchVerifier.connect(user1).verifyMatchHistory(
        VALID_PROOF.pA,
        VALID_PROOF.pB,
        VALID_PROOF.pC,
        VALID_PROOF.pubSignals
      );

      const [verified, minMatches, minWinRate, commitment] =
        await matchVerifier.getVerification(user1.address);

      expect(verified).to.be.true;
      expect(minMatches).to.equal(10);
      expect(minWinRate).to.equal(6000);
      expect(commitment).to.equal(COMMITMENT);
    });
  });
});
