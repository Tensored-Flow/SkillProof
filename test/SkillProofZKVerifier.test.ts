import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";

describe("SkillProofZKVerifier", function () {
  // Real proof generated by snarkjs from our circom circuit.
  // Circuit: ThresholdProof — proves ELO >= threshold without revealing ELO.
  // Input: elo=1847, threshold=1500, salt=12345
  // commitment = elo + salt * 2^32 = 53021371270967

  const VALID_PROOF = {
    pA: [
      "0x1311eb7ce1914fd5a34ff83ba47ca370c79294445d43f49e462300619b602d56",
      "0x1e224c9d81a8b99fa8eea974a8ec6b95726f1a78bf958dc020439dee852fa13c",
    ] as [string, string],
    pB: [
      [
        "0x0e3c41ba228f8d698d7c79f6746b40de00a63ff42d88a1c56b4126c9fd971921",
        "0x2934a1256f0626642b19da26923b5a3ddfefbf3d1c55cbe1010d883dc52c9389",
      ],
      [
        "0x1951152415aa496573c3e5b9c742f7aa1a85bc3e4b26b76527ac91a292d37451",
        "0x1bd95d47d32a65666890c752e20690924ef79f632959a3b58044cc0ff87dd8ca",
      ],
    ] as [[string, string], [string, string]],
    pC: [
      "0x15d47f4d98be46b20af404ef02dc557f4f844d7a4149a1cdbd04cedc253d7d0b",
      "0x0ce2ed2df29c1a27399c365f10b51da47c3a45b79e6635c6577ad6415d529584",
    ] as [string, string],
    pubSignals: [
      "0x0000000000000000000000000000000000000000000000000000000000000001", // valid = 1
      "0x00000000000000000000000000000000000000000000000000000000000005dc", // threshold = 1500
      "0x0000000000000000000000000000000000000000000000000000303900000737", // commitment
    ] as [string, string, string],
  };

  async function deployZKFixture() {
    const [owner, user1, user2] = await ethers.getSigners();

    // Deploy Groth16Verifier (snarkjs-generated)
    const Groth16Factory = await ethers.getContractFactory("Groth16Verifier");
    const groth16Verifier = await Groth16Factory.deploy();

    // Deploy SkillProofZKVerifier wrapper
    const ZKFactory = await ethers.getContractFactory("SkillProofZKVerifier");
    const zkVerifier = await ZKFactory.deploy(await groth16Verifier.getAddress());

    return { groth16Verifier, zkVerifier, owner, user1, user2 };
  }

  describe("Deployment", function () {
    it("Should set the Groth16Verifier address", async function () {
      const { groth16Verifier, zkVerifier } = await loadFixture(deployZKFixture);
      expect(await zkVerifier.groth16Verifier()).to.equal(
        await groth16Verifier.getAddress()
      );
    });

    it("Should start with zero verification count", async function () {
      const { zkVerifier } = await loadFixture(deployZKFixture);
      expect(await zkVerifier.zkVerificationCount()).to.equal(0);
    });
  });

  describe("Valid Proof Verification", function () {
    it("Should accept a valid ZK-SNARK proof", async function () {
      const { zkVerifier, user1 } = await loadFixture(deployZKFixture);

      await expect(
        zkVerifier
          .connect(user1)
          .verifyThresholdZK(
            VALID_PROOF.pA,
            VALID_PROOF.pB,
            VALID_PROOF.pC,
            VALID_PROOF.pubSignals
          )
      )
        .to.emit(zkVerifier, "ZKThresholdVerified")
        .withArgs(user1.address, 1500, "53021371270967");
    });

    it("Should record verification state after valid proof", async function () {
      const { zkVerifier, user1 } = await loadFixture(deployZKFixture);

      await zkVerifier
        .connect(user1)
        .verifyThresholdZK(
          VALID_PROOF.pA,
          VALID_PROOF.pB,
          VALID_PROOF.pC,
          VALID_PROOF.pubSignals
        );

      expect(await zkVerifier.isZKVerified(user1.address)).to.be.true;
      expect(await zkVerifier.getVerifiedThreshold(user1.address)).to.equal(1500);
      expect(await zkVerifier.getVerifiedCommitment(user1.address)).to.equal(
        "53021371270967"
      );
      expect(await zkVerifier.zkVerificationCount()).to.equal(1);
    });

    it("Should allow multiple users to verify independently", async function () {
      const { zkVerifier, user1, user2 } = await loadFixture(deployZKFixture);

      await zkVerifier
        .connect(user1)
        .verifyThresholdZK(
          VALID_PROOF.pA,
          VALID_PROOF.pB,
          VALID_PROOF.pC,
          VALID_PROOF.pubSignals
        );

      await zkVerifier
        .connect(user2)
        .verifyThresholdZK(
          VALID_PROOF.pA,
          VALID_PROOF.pB,
          VALID_PROOF.pC,
          VALID_PROOF.pubSignals
        );

      expect(await zkVerifier.isZKVerified(user1.address)).to.be.true;
      expect(await zkVerifier.isZKVerified(user2.address)).to.be.true;
      expect(await zkVerifier.zkVerificationCount()).to.equal(2);
    });

    it("Should allow re-verification with updated threshold", async function () {
      const { zkVerifier, user1 } = await loadFixture(deployZKFixture);

      await zkVerifier
        .connect(user1)
        .verifyThresholdZK(
          VALID_PROOF.pA,
          VALID_PROOF.pB,
          VALID_PROOF.pC,
          VALID_PROOF.pubSignals
        );

      expect(await zkVerifier.getVerifiedThreshold(user1.address)).to.equal(1500);
      expect(await zkVerifier.zkVerificationCount()).to.equal(1);

      // Re-verify (same proof but counts again)
      await zkVerifier
        .connect(user1)
        .verifyThresholdZK(
          VALID_PROOF.pA,
          VALID_PROOF.pB,
          VALID_PROOF.pC,
          VALID_PROOF.pubSignals
        );

      expect(await zkVerifier.zkVerificationCount()).to.equal(2);
    });
  });

  describe("Invalid Proof Rejection", function () {
    it("Should reject proof with tampered pA", async function () {
      const { zkVerifier, user1 } = await loadFixture(deployZKFixture);

      const tamperedPA: [string, string] = [
        "0x0000000000000000000000000000000000000000000000000000000000000001",
        "0x0000000000000000000000000000000000000000000000000000000000000002",
      ];

      await expect(
        zkVerifier
          .connect(user1)
          .verifyThresholdZK(
            tamperedPA,
            VALID_PROOF.pB,
            VALID_PROOF.pC,
            VALID_PROOF.pubSignals
          )
      ).to.be.revertedWith("ZK proof invalid");
    });

    it("Should reject proof with tampered public signals", async function () {
      const { zkVerifier, user1 } = await loadFixture(deployZKFixture);

      // Change threshold from 1500 to 1400 — proof should fail
      const tamperedSignals: [string, string, string] = [
        VALID_PROOF.pubSignals[0],
        "0x0000000000000000000000000000000000000000000000000000000000000578", // 1400
        VALID_PROOF.pubSignals[2],
      ];

      await expect(
        zkVerifier
          .connect(user1)
          .verifyThresholdZK(
            VALID_PROOF.pA,
            VALID_PROOF.pB,
            VALID_PROOF.pC,
            tamperedSignals
          )
      ).to.be.revertedWith("ZK proof invalid");
    });

    it("Should reject proof with invalid circuit output (valid != 1)", async function () {
      const { zkVerifier, user1 } = await loadFixture(deployZKFixture);

      const badSignals: [string, string, string] = [
        "0x0000000000000000000000000000000000000000000000000000000000000000", // valid = 0
        VALID_PROOF.pubSignals[1],
        VALID_PROOF.pubSignals[2],
      ];

      await expect(
        zkVerifier
          .connect(user1)
          .verifyThresholdZK(
            VALID_PROOF.pA,
            VALID_PROOF.pB,
            VALID_PROOF.pC,
            badSignals
          )
      ).to.be.revertedWith("Invalid circuit output");
    });

    it("Should reject proof with tampered commitment", async function () {
      const { zkVerifier, user1 } = await loadFixture(deployZKFixture);

      const tamperedSignals: [string, string, string] = [
        VALID_PROOF.pubSignals[0],
        VALID_PROOF.pubSignals[1],
        "0x0000000000000000000000000000000000000000000000000000000000000001", // wrong commitment
      ];

      await expect(
        zkVerifier
          .connect(user1)
          .verifyThresholdZK(
            VALID_PROOF.pA,
            VALID_PROOF.pB,
            VALID_PROOF.pC,
            tamperedSignals
          )
      ).to.be.revertedWith("ZK proof invalid");
    });

    it("Should not record state for rejected proofs", async function () {
      const { zkVerifier, user1 } = await loadFixture(deployZKFixture);

      const tamperedPA: [string, string] = [
        "0x0000000000000000000000000000000000000000000000000000000000000001",
        "0x0000000000000000000000000000000000000000000000000000000000000002",
      ];

      try {
        await zkVerifier
          .connect(user1)
          .verifyThresholdZK(
            tamperedPA,
            VALID_PROOF.pB,
            VALID_PROOF.pC,
            VALID_PROOF.pubSignals
          );
      } catch {}

      expect(await zkVerifier.isZKVerified(user1.address)).to.be.false;
      expect(await zkVerifier.zkVerificationCount()).to.equal(0);
    });
  });

  describe("View Functions", function () {
    it("Should return false for unverified users", async function () {
      const { zkVerifier, user1 } = await loadFixture(deployZKFixture);
      expect(await zkVerifier.isZKVerified(user1.address)).to.be.false;
    });

    it("Should return 0 threshold for unverified users", async function () {
      const { zkVerifier, user1 } = await loadFixture(deployZKFixture);
      expect(await zkVerifier.getVerifiedThreshold(user1.address)).to.equal(0);
    });

    it("Should return 0 commitment for unverified users", async function () {
      const { zkVerifier, user1 } = await loadFixture(deployZKFixture);
      expect(await zkVerifier.getVerifiedCommitment(user1.address)).to.equal(0);
    });

    it("Should return correct count via getZKVerificationCount", async function () {
      const { zkVerifier, user1 } = await loadFixture(deployZKFixture);

      expect(await zkVerifier.getZKVerificationCount()).to.equal(0);

      await zkVerifier
        .connect(user1)
        .verifyThresholdZK(
          VALID_PROOF.pA,
          VALID_PROOF.pB,
          VALID_PROOF.pC,
          VALID_PROOF.pubSignals
        );

      expect(await zkVerifier.getZKVerificationCount()).to.equal(1);
    });
  });
});
